#!/bin/bash
#
# live-dl
# Download live streams from YouTube
#
# Tunghsiao Liu <t@sparanoid.com>
# Released under AGPL-3.0
#

#
# System reqirements
#
# - aria2c
# - bash
# - exiv2
# - ffmpeg
# - jq
# - streamlink
# - yt-dlp
# - yq (python-yq)
#

#
# Changelog
#
# See https://github.com/sparanoid/live-dl
#

#
# To-do list
#
# - [x] dependencies check
# - [x] convert output from .ts to .mp4
# - [x] youtube playlist support (not perfect when writing metadata)
# - [x] thumbnail size check
# - [x] write metadata and cover
# - [x] email notification
# - [x] mailgun setup guide
# - [x] slack notification
# - [x] telegram notification
# - [x] discord notification
# - [x] refine telegram multichannel support
# - [x] channel name mapping
# - [x] download base dir support
# - [ ] upcoming streams detection
# - [x] keyword filter
# - [x] summary output for uploading
# - [x] recording summary
# - [x] embed cover
# - [x] add hostname to output
# - [x] dockerize this script
# - [x] rewrite is_live detection logic
#

#
# Variables
#
BIN_VERSION="2.0.0"

# DEPRECATED: use `user_agent` in `config.yml` instead. This is for backward compatibility.
LEGACY_USER_AGENT="Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36"

#
# Functions
#

# Text color helper borrowed from acme.sh
__green() {
  printf '\033[1;31;32m%b\033[0m' "$1"
}

__yellow() {
  printf '\033[1;31;33m%b\033[0m' "$1"
}

__red() {
  printf '\033[1;31;40m%b\033[0m' "$1"
}

__info() {
  printf "[$(date)] %s\n" "$1"
}

__debug() {
  DEBUG="${PARAM_DEBUG:-"false"}"
  if [ "$DEBUG" == "true" ]; then
    printf "[$(date)] DEBUG: %s\n" "$1"
  fi
}

# Convert secs to HH:MM:SS format
__convert_seconds() {
  # https://stackoverflow.com/a/39452629/412385
  printf '%02d:%02d:%02d\n' $(($1/3600)) $(($1%3600/60)) $(($1%60))
}

# Set the current working directory to the directory of this script
# http://stackoverflow.com/a/17744637/412385
cd ${0%/*}

# Prepare options
POSITIONAL=()
while [ $# -gt 0 ]; do
  key="$1"

  case $key in
    -e|--extension)
      EXTENSION="$2"
      shift # past argument
      shift # past value
      ;;
    -m|--mode)
      PARAM_MODE="$2"
      shift
      shift
      ;;
    --filter)
      PARAM_FILTER="$2"
      shift
      shift
      ;;
    -o|--output)
      PARAM_BASE_DIR="$2"
      shift
      shift
      ;;
    -i|--interval)
      PARAM_INTERVAL="$2"
      shift
      shift
      ;;
    -u|--user-agent)
      PARAM_USER_AGENT="$2"
      shift
      shift
      ;;
    --image-proxy)
      PARAM_IMAGE_PROXY="$2"
      shift
      shift
      ;;
    --ytdl-stream)
      PARAM_YTDL_STREAM=true
      shift
      ;;
    --ytdl-args)
      PARAM_YTDL_ARGS="$2"
      shift
      shift
      ;;
    --streamlink-args)
      PARAM_STREAMLINK_ARGS="$2"
      shift
      shift
      ;;
    --init)
      PARAM_INIT_SCRIPT=true
      shift
      ;;
    --debug)
      PARAM_DEBUG=true
      shift
      ;;
    --skip-convert)
      PARAM_SKIP_CONVERT=true
      shift
      ;;
    --skip-metadata)
      PARAM_SKIP_METADATA=true
      shift
      ;;
    --skip-email)
      PARAM_SKIP_EMAIL=true
      shift
      ;;
    --skip-slack)
      PARAM_SKIP_SLACK=true
      shift
      ;;
    --skip-telegram)
      PARAM_SKIP_TELEGRAM=true
      shift
      ;;
    --skip-discord)
      PARAM_SKIP_DISCORD=true
      shift
      ;;
    -1|--once)
      PARAM_ONE_TIME=true
      shift
      ;;
    -v|--version)
      PARAM_SHOW_VERSION=true
      shift
      ;;
    *) # other unknown options
      POSITIONAL+=("$1") # save it in an array for later
      shift
      ;;
  esac
done

# restore positional parameters
set -- "${POSITIONAL[@]}"

# Install repo for CentOS/RHEL
function func_add_repo_rhel() {
  rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro
  rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm
}

# Check dependencies
function func_check_deps() {
  __info "Checking dependencies..."

  if command -v ffmpeg >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(ffmpeg -version | head -n 1)"
  else
    __info "FFmpeg not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        yum install epel-release -y
        func_add_repo_rhel
        yum install ffmpeg -y
      fi
      if [ -f /etc/lsb-release ]; then
        apt-get install ffmpeg -y
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install ffmpeg
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v yt-dlp >/dev/null 2>&1 ; then
    __info "$(__green "Found"): yt-dlp $(yt-dlp --version | head -n 1)"
  else
    __info "yt-dlp not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      curl -L https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -o /usr/local/bin/yt-dlp
      chmod a+rx /usr/local/bin/yt-dlp
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install yt-dlp
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v jq >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(jq --version | head -n 1)"
  else
    __info "jq not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        yum install epel-release -y
        yum install jq -y
      fi
      if [ -f /etc/lsb-release ]; then
        apt-get install jq -y
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install jq
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v yq >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(yq --version | head -n 1)"
  else
    __info "yq not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        pip install yq
      fi
      if [ -f /etc/lsb-release ]; then
        apt install python-pip
        pip install yq
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install python-yq
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v exiv2 >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(exiv2 --version | head -n 1)"
  else
    __info "exiv2 not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        yum install exiv2 -y
      fi
      if [ -f /etc/lsb-release ]; then
        apt-get install exiv2 -y
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install exiv2
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v aria2c >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(aria2c -v | head -n 1)"
  else
    __info "aria2 not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        yum install epel-release -y
        yum install aria2 -y
      fi
      if [ -f /etc/lsb-release ]; then
        apt-get install aria2 -y
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install aria2
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v streamlink >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(streamlink --version | head -n 1)"
  else
    __info "streamlink not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        pip install streamlink
      fi
      if [ -f /etc/lsb-release ]; then
        add-apt-repository ppa:nilarimogard/webupd8
        apt install streamlink
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install streamlink
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi
}

function func_create_url() {
  # Create correct URL/URI based on user input
  #
  # https://www.youtube.com/channel/UCxRuOqAAVo-f516Gygjh_wA/live
  # https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg
  # https://www.youtube.com/watch?v=S3CAGeeMRvo
  # https://www.youtube.com/playlist?list=UU1opHUrw8rvnsadT-iGp7Cg
  # https://www.youtube.com/feed/subscriptions
  # https://live.bilibili.com/14917277
  # https://live.bilibili.com/456117
  #

  local _url=$1

  if [[ "$_url" =~ "youtube.com" ]]; then
    __info "YouTube URL detected"
    DL_PLATFORM="YouTube"

    if [[ "$_url" =~ "/channel" && "$_url" =~ "/live" ]]; then
      __info "YouTube channel detected"
      DL_URL="$_url"
      DL_TYPE="channel"

    elif [[ "$_url" =~ "/channel" && ! "$_url" =~ "/live" ]]; then
      __info "YouTube video detected (alt)"
      DL_URL="$_url/live"
      DL_TYPE="channel"

    elif [[ "$_url" =~ "/watch"* ]]; then
      __info "YouTube video detected"
      DL_URL="$_url"
      DL_TYPE="video"

    elif [[ "$_url" =~ "/playlist"* ]]; then
      __info "YouTube playlist detected"
      DL_URL="$_url"
      DL_TYPE="playlist"

    else
      __info "$(__red "Non-supported YouTube URL")"
      exit 1
    fi

  elif [[ "$_url" =~ "live.bilibili.com" ]]; then
    __info "Bilibili detected"
    DL_URL="$_url"
    DL_PLATFORM="bilibili"

  else
    if [[ ! "$_url" == "http"* ]]; then
      __info "$(__yellow "URI detected, guessing... (Use full URL to avoid guessing URL)")"

      if [[ "$_url" =~ ^([0-9]+)$ ]]; then
        __info "Bilibili room ID detected"
        DL_URL="https://live.bilibili.com/$_url"
        DL_PLATFORM="bilibili"

      # if URI is longer than 11 (11 is the length of YouTube video ID)
      elif [[ ${#_url} -ge 12 ]]; then
        __info "YouTube channel ID detected"
        DL_URL="https://www.youtube.com/channel/$_url/live"
        DL_PLATFORM="YouTube"
        DL_TYPE="channel"

      else
        __info "YouTube video ID detected"
        DL_URL="https://www.youtube.com/watch?v=$_url"
        DL_PLATFORM="YouTube"
        DL_TYPE="video"
      fi

    else
      __info "$(__red "Non-supported URL")"
      exit 1
    fi
  fi
}

function func_check_state() {
  local _url=$1
  local _mode=$2

  __debug "start func_check_state"

  # Assume it's not a valid page, I use a custom state `invalid` here as initial state
  CONTENT_STATE="invalid"

  if [ "$DL_PLATFORM" == "YouTube" ]; then
    # Actually there's an official way to check if the streamer is live or not[^1] using YouTube
    # offical Data API, but it's costy that every search request costs you 100 credits. However
    # you can try it online[^2] to see how it works.
    #
    # If you have accounts that registered YouTube developer program before 2017, and has more
    # than 10 million credit quota, you can contact me t@sparanoid.com
    #
    # [1]: https://developers.google.com/youtube/v3/docs/search
    # [2]: https://developers.google.com/youtube/v3/code_samples/code_snippets

    # First check: use curl to check HTML pages for live state
    # Pros:
    # - Fast, no additional API requests compared to yt-dlp
    # - More ban-proof compared to yt-dlp
    # Cons:
    # - Can get wrong live state due to page caching, network interrupts, etc.
    METADATA_CURL_RAW=$(curl -b cookies.txt -s --compressed -H "User-Agent: $USER_AGENT" "$_url")

    # Match only JSON part
    # https://regex101.com/r/QiyZE2/3
    #
    # Debug commmand if YouTube changes its HTML structure in the future:
    # $ curl -s --compressed -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36" 'https://www.youtube.com/watch?v=j2z06YUbulk' | grep 'ytInitialPlayerResponse' | grep '<script' | grep 'responseContext' | perl -pe 's/^.*?ytInitialPlayerResponse = ({".*]});var .*/\1/g' | jq -r .
    METADATA_CURL=`echo "$METADATA_CURL_RAW" | sed -n 's/.*var ytInitialPlayerResponse = \({[^<]*}\);.*/\1/p' | jq -r .`

    # Check if returns nothing
    if [ ! -z "$METADATA_CURL" ]; then
      __debug "Got valid cURL metadata"

      # At the time of writing, when `videoDetails.isLive` exists, it should be on live, when a video
      # is not live (normal videos, and even upcoming streams) this key will be missing and jq will
      # return `null`
      IS_LIVE=$(echo "$METADATA_CURL" | jq -r '.videoDetails.isLive | select(.!=null)')
      __debug "Is live: $IS_LIVE"

      # This status will always return:
      # - `OK` for live streams, private streams, or normal videos,
      # - `LIVE_STREAM_OFFLINE` for offline channel
      PLAYABILITY=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.status | select(.!=null)')
      __debug "Playability: $PLAYABILITY"

      # You will get some playability reasons for:
      # - `Offline` for streams are not live
      # - `This live event will begin in {n} hours.` for upcoming streams, you can also get specific
      #   UNIX timestamp with .scheduledStartTime (see below)
      # - `null` (this key will be missing) for:
      #   - On live streams or private streams
      #   - Non-streaming content
      PLAYABILITY_REASON=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.reason | select(.!=null)')
      __debug "Playability Reason: $PLAYABILITY_REASON"

      # When the streamer is streaming privately, this key will be empty
      STREAMABILITY=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.liveStreamability.liveStreamabilityRenderer.videoId | select(.!=null)')
      __debug "Streamability ID: $STREAMABILITY"

      # Get upcoming time when available
      # This key will be missing if no upcoming events available
      UPCOMING_TIME=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.liveStreamability.liveStreamabilityRenderer.offlineSlate.liveStreamOfflineSlateRenderer.scheduledStartTime | select(.!=null)')
      if [ ! -z "$UPCOMING_TIME" ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
          local _date_calc=`date -r $UPCOMING_TIME`
        else
          local _date_calc=`date -d @$UPCOMING_TIME`
        fi

        __debug "Scheduled Time: $_date_calc ($UPCOMING_TIME)"
      fi

      # Get some metadata first, I will retrieve more later using yt-dlp
      VIDEO_ID=$(echo "$METADATA_CURL" | jq -r '.videoDetails.videoId')
      FULLTITLE=$(echo "$METADATA_CURL" | jq -r '.videoDetails.title')
      DESCRIPTION=$(echo "$METADATA_CURL" | jq -r '.videoDetails.shortDescription')
      UPLOADER=$(echo "$METADATA_CURL" | jq -r '.videoDetails.author')
      CHANNEL_ID=$(echo "$METADATA_CURL" | jq -r '.videoDetails.channelId')

      # Print basic metadata for reference
      __debug "Channel: $UPLOADER"
      __debug "Title: $FULLTITLE"

      # NOTE: Oct 25, 2020
      # With recent changes of YouTube API, you cannot get live JSON from a /live channel URL.
      # This causes empty response during yt-dlp second check. So I redirect channel page check to
      # video page check after I got the specific video ID.
      if ([ "$DL_TYPE" == "channel" ] && [ "$DL_PLATFORM" == "YouTube" ]); then
        _url="https://www.youtube.com/watch?v=$VIDEO_ID"
      fi

      # If I got `isLive: true` in first check, let me assume it's live but I can't trust it so I
      # will do a secound check using yt-dlp later with this flag.
      if [ "$IS_LIVE" == "true" ]; then
        __info "cURL check seems goes live now, continue checking..."

        if [ ! -z "$FILTER" ]; then
          __debug "User filter found: $(__yellow "$FILTER"). Checking if video title matches..."

          if [[ "$FULLTITLE" =~ $FILTER ]]; then
            __info "$(__green "Video title matched, mark as downloadable...")"
            CONTENT_STATE="live"
          else
            __info "$(__yellow "Video title does not match, skipping and continue monitoring...")"
            CONTENT_STATE="invalid"
          fi
        else
          __debug "No user filter found, mark as downloadable..."
          CONTENT_STATE="live"
        fi
      else
        # If `isLive` key not exists, check if it's a valid video (playable)
        if [ "$PLAYABILITY" == "OK" ]; then

          # Then check if it's a channel URL
          if [ "$DL_TYPE" == "channel" ]; then

            # Check if the streamer is streaming privately.
            if [ -z "$STREAMABILITY" ]; then
              __info "$(__yellow "/live redirects to /, event mode or streaming privately?")"
            fi
          else
            CONTENT_STATE="video"
          fi
        fi

        # Then check if the stream just goes offline
        if [ "$PLAYABILITY" == "LIVE_STREAM_OFFLINE" ]; then
          CONTENT_STATE="offline"

          # Check if upcoming event available
          if [ ! -z "$UPCOMING_TIME" ]; then
            __info "$(__yellow "Upcoming event detected: $UPCOMING_TIME")"
          fi
        fi
      fi

      # Print current state for first check
      __debug "Current state for first check: $(__yellow "$CONTENT_STATE")"
    else
      # Nov 14, 2021: YouTube no longer retuns a valid JSON response for /live channel URL when the
      # channel is not live. So just silent fail here.
      if ([ "$DL_TYPE" == "channel" ] && [ "$DL_PLATFORM" == "YouTube" ]); then
        __debug "$(__yellow "Channel page is offline with no JSON extracted")"
      else
        __info "$(__yellow "Not a valid page, something wrong with your internet connection?")"
      fi
    fi

    # Old method:
    # if echo "$_body" | grep -q 'ytplayer'; then

    #   # Assume it's not a live streaming page
    #   IS_LIVE_CONTENT="false"

    #   # Actually there's an official way to check if the streamer is live or not[^1] using YouTube
    #   # offical Data API, but it's costy that every search request costs you 100 credits. However
    #   # you can try it online[^2] to see how it works.
    #   #
    #   # If you have accounts that registered YouTube developer program before 2017, and has more
    #   # than 10 million credit quota, you can contact me t@sparanoid.com
    #   #
    #   # [1]: https://developers.google.com/youtube/v3/docs/search
    #   # [2]: https://developers.google.com/youtube/v3/code_samples/code_snippets
    #   if echo "$_body" | grep 'ytplayer' | grep -q '\\"isLive\\":true'; then
    #     # Is live, break out of loop and continue to next step
    #     IS_LIVE_CONTENT="true"
    #     break
    #   fi

    #   # Also break out if the given URL is not a channel (probably a video or a playlist)
    #   # This extra check could avoid downloading an upcoming stream when then "isLive" check above
    #   # fails for some reason (like YouTube changes the `isLive` JSON key to something else)
    #   if ! [ "$DL_TYPE" == "channel" ]; then
    #     # This script now can also handle normal YouTube video, but there's no way to check if the
    #     # given URL is a normal video or an upcoming stream, so we can just break out of the loop
    #     # and fallback to yt-dlp to check whelter this URL is downloadable. And make sure it
    #     # only execute once.
    #     ONE_TIME="true"
    #     break
    #   fi

    # else
    #   __info "$(__yellow "Not a valid video page!")"
    #   __info "You may get this warning due to internet interruption, continue running"

    #   # NOTE: Although this is the natural logic to exit the program if we can't find specific
    #   # element on this page that means it's not a valid video page. But in some rare cases, the
    #   # original page may be down or unreachable for internet interruption or other network issues.
    #   # So I decide to let the script continue to execute because this script is mainly focused on
    #   # recording streams.

    #   # exit 1
    # fi

    # Second check: use `yt-dlp` to check live state
    # NOTE: please avoid adding additional paths in the -o (template) option, it doesn't work well
    # and conflicts with my custom directory setup!
    # I also need redirect stderr to stdout to catch any error during fetching URL
    # Pros:
    # - Accurate live state detection
    # Cons:
    # - Slow, yt-dlp will fire API requests to get more info it need to download videos
    # - Your IP can get banned easily when running in download or notifier mode due to large amount of
    #   API requests.
    if [ "$CONTENT_STATE" != "invalid" ]; then

      # Condition explain:
      # Only run second check when:
      # - The stream goes live that need a second check to ensure it's actually live
      # - The stream goes offline that need a second check to ensure it's actually offline
      if ([ "$CONTENT_STATE" != "offline" ] && [ "$_mode" != "lazy" ]) || \
        ([ "$CONTENT_STATE" == "offline" ] && [ "$_mode" == "lazy" ])
      then
        __info "Re-checking via yt-dlp..."
        METADATA=`yt-dlp --ignore-config --no-playlist --playlist-items 0 --no-warnings \
          --skip-download --print-json --referer 'https://www.youtube.com/feed/subscriptions' \
          --cookies cookies.txt $YTDL_ARGS -o '%(upload_date)s %(title)s (%(id)s).%(ext)s' \
          "$_url" 2>&1`

        # Check if returns nothing
        if [ ! -z "$METADATA" ]; then
          __debug "Got valid yt-dlp metadata"

          # Check if it's a valid JSON return
          if [[ "$METADATA" == '{'* ]]; then
            # Unlike other part of the jq checks, I ignore the `| select(.!=null)` to explicitly
            # return `null` to tell if it's a normal video or it just returns nothing
            local _is_live=`echo "$METADATA" | jq -r '.is_live'`

            # Parse metadata
            func_process_youtube_metadata

            # Map uploader name with pre-defined config
            func_process_channel_mapping

            # Finalize variables and paths then output summary
            func_finalize_vars

            if [ "$_is_live" == "true" ]; then
              __debug "Got state: live";
              CONTENT_STATE="live"
            elif [ "$_is_live" == "false" ]; then
              __debug "Got state: video";
              CONTENT_STATE="video"
            else
              __info "yt-dlp does not returns a valid state";
              CONTENT_STATE="invalid"
            fi
          else
            __debug "$METADATA"
            if [[ "$METADATA" =~ "This video is unavailable" ]]; then
              # Suppress `video is unavailable` errors since they're common when stream is not live
              # NOTE: Nov 17, 2021: Now YouTube no longer returns any JSON response for offline channels
              # so all offline state will fallback to `invalid` at the moment
              __debug "This video is unavailable, maybe not live at the moment."
              CONTENT_STATE="unavailable"
            elif [[ "$METADATA" =~ "HTTP Error 404" ]]; then
              __info "$(__yellow "Not a valid video page (Error 404)!")"
              CONTENT_STATE="not_found"
            elif [[ "$METADATA" =~ "HTTP Error 429" ]]; then
              __info "$(__yellow "Your IP is limited by YouTube (Error 429)!")"
              CONTENT_STATE="too_many_requests"
            else
              __info "$(__yellow "Unknown metadata")"
              __info "$METADATA"
              CONTENT_STATE="invalid"
            fi
          fi
        else
          __info "$(__yellow "Second check failed, not valid yt-dlp metadata")"
          CONTENT_STATE="invalid"
        fi

        # Print current state for second check
        __debug "Current state for second check: $(__yellow "$CONTENT_STATE")"
      fi
    fi
  fi
}

function func_send_email() {
  local _title=$1
  local _content=$2

  if [ "$SKIP_EMAIL" != "true" ]; then

    if [ "$CONFIG_EMAIL_PROVIDER" == "mailgun" ]; then

      if [ "$CONFIG_MAILGUN_API" == "key-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" ]; then
        __info "$(__yellow "No Mailgun credentials found, skip sending email notification")"
      else
        __info "Sending email notification..."
        curl -s --user "api:$CONFIG_MAILGUN_API" \
          https://api.mailgun.net/v3/"$CONFIG_MAILGUN_DOMAIN"/messages \
          -F from="Livestream Downloader (live-dl) <live-dl@$CONFIG_MAILGUN_DOMAIN>" \
          -F to="$CONFIG_MAILGUN_RECEIPT" \
          -F subject="$_title" \
          -F text="$_content" >> "$OUTPUT_PATH.log" 2>&1
      fi
    fi

    if [ "$CONFIG_EMAIL_PROVIDER" == "ses" ]; then

      if [ "$CONFIG_SES_ACCESS" == "AKxxxxxxxxxxxxxxxxxx" ]; then
        __info "$(__yellow "No AWS SES credentials found, skip sending email notification")"
      else
        __info "Sending email notification..."
        local FROM="Livestream Downloader (live-dl) <live-dl@$CONFIG_SES_DOMAIN>"

        local ses_date="$(date -R)"
        # base64 different behavior alert:
        # https://stackoverflow.com/a/46464081/412385
        # Just use `base64` or `base64 -b 0` on macOS, on other platforms, use:
        # `base64 -w 0`
        local ses_signature="$(echo -n "$ses_date" | openssl dgst -sha256 -hmac "$CONFIG_SES_SECRET" -binary | base64)"
        local ses_auth_header="X-Amzn-Authorization: AWS3-HTTPS AWSAccessKeyId=$CONFIG_SES_ACCESS, Algorithm=HmacSHA256, Signature=$ses_signature"
        local ses_endpoint="https://email.us-east-1.amazonaws.com/"
        local ses_action="Action=SendEmail"
        local ses_source="Source=$FROM"
        local ses_to="Destination.ToAddresses.member.1=$TO"
        local ses_subject="Message.Subject.Data=$_title"
        local ses_message="Message.Body.Text.Data=$_content"

        curl -X POST -H "Date: $ses_date" -H "$ses_auth_header" \
          --data-urlencode "$ses_message" \
          --data-urlencode "$ses_to" \
          --data-urlencode "$ses_source" \
          --data-urlencode "$ses_action" \
          --data-urlencode "$ses_subject" \
          "$ses_endpoint" >/dev/null 2>&1
      fi
    fi
  fi
}

function func_send_slack() {
  local _type=$1

  if [ "$SKIP_SLACK" != "true" ]; then

    if [ "$CONFIG_SLACK_WEBHOOK" == "https://hooks.slack.com/services/" ]; then
      __info "$(__yellow "No Slack credentials found, skip sending Slack notification")"
    else
      __info "Sending Slack notification..."

      if [ "$_type" == "start" ]; then
        local _body='{
          "icon_emoji": ":red_circle:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "ID",
                  "value": "<'"$WEBPAGE_URL"'|'"$VIDEO_ID"'>",
                  "short": true
                },
                {
                  "title": "Channel",
                  "value": "<'"$CHANNEL_URL"'|'"$CHANNEL_ID"'>",
                  "short": true
                },
                {
                  "title": "Thumbnail",
                  "value": "<'"$THUMBNAIL_CALC"'|View in new tab>",
                  "short": true
                },
                {
                  "title": "Date",
                  "value": "'"$UPLOAD_DATE"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      elif [ "$_type" == "stop" ]; then
        local _body='{
          "icon_emoji": ":black_square:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "Views",
                  "value": "'"$VIEW_COUNT"'",
                  "short": true
                },
                {
                  "title": "Likes",
                  "value": "'"$LIKE_COUNT"'",
                  "short": true
                },
                {
                  "title": "Dislikes",
                  "value": "'"$DISLIKE_COUNT"'",
                  "short": true
                },
                {
                  "title": "Average Rating",
                  "value": "'"$AVERAGE_RATING"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      else
        local _body='{
          "icon_emoji": ":ghost:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "ID",
                  "value": "<'"$WEBPAGE_URL"'|'"$VIDEO_ID"'>",
                  "short": true
                },
                {
                  "title": "Channel",
                  "value": "<'"$CHANNEL_URL"'|'"$CHANNEL_ID"'>",
                  "short": true
                },
                {
                  "title": "Thumbnail",
                  "value": "<'"$THUMBNAIL_CALC"'|View in new tab>",
                  "short": true
                },
                {
                  "title": "Date",
                  "value": "'"$UPLOAD_DATE"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      fi

      curl -s -X POST -H 'Content-type: application/json' \
        -d "$_body" "$CONFIG_SLACK_WEBHOOK"
    fi
  fi
}

function func_send_telegram() {
  local _type=$1

  # https://core.telegram.org/bots/api
  if [ "$SKIP_TELEGRAM" != "true" ]; then

    if [ "$CONFIG_TELEGRAM_BOT" == "000000000:xxxxxxxxx" ]; then
      __info "$(__yellow "No Telegram credentials found, skip sending Telegram notification")"
    else
      if [ "$UPLOADER_TG_CHANNEL" ]; then
        __info "Sending Telegram notification..."
        local _time_start=$(TZ=":$UPLOADER_TIMEZONE" date +"%b %e %H:%M %Z (%z)")

        if [ "$_type" == "start" ]; then
          local _type="sendPhoto"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "photo": "'"$THUMBNAIL_CALC"'",
            "caption": "ðŸ”´ '"$UPLOADER"' goes live on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n\nStarts on '"$_time_start"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch it now", "url": "'"$WEBPAGE_URL"'"}
                ],
                [
                  {"text": "View channel", "url": "'"$CHANNEL_URL"'"},
                  {"text": "View artwork", "url": "'"$IMAGE_PROXY$THUMBNAIL_CALC"'"}
                ]
              ]
            },
            "disable_notification": false
          }'
        elif [ "$_type" == "stop" ]; then
          local _type="sendMessage"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "text": "â¬›ï¸ '"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n\nViews: '"$VIEW_COUNT"'\nLikes: '"$LIKE_COUNT"'\nDislikes: '"$DISLIKE_COUNT"'\nAverage Rating: '"$AVERAGE_RATING"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch finished stream", "url": "'"$WEBPAGE_URL"'"}
                ]
              ]
            },
            "disable_notification": true
          }'
        else
          local _type="sendMessage"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "text": "ðŸ”´ '"$UPLOADER"' goes live on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n'"$WEBPAGE_URL"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch it now", "url": "'"$WEBPAGE_URL"'"}
                ],
                [
                  {"text": "View channel", "url": "'"$CHANNEL_URL"'"},
                  {"text": "View artwork", "url": "'"$IMAGE_PROXY$THUMBNAIL_CALC"'"}
                ]
              ]
            },
            "disable_notification": false
          }'
        fi

        curl -s -X POST -H 'Content-Type: application/json' \
          -d "$_body" "https://api.telegram.org/bot$CONFIG_TELEGRAM_BOT/$_type"
      else
        __info "No specific channel set for current user, skip sending Telegram notification."
      fi
    fi
  fi
}

function func_send_discord() {
  local _type=$1

  if [ "$SKIP_DISCORD" != "true" ]; then
    CURRENT_DISCORD_WEBOOK="$CONFIG_DISCORD_WEBHOOK"
    if [ "$UPLOADER_DISCORD_URL" ]; then
      CURRENT_DISCORD_WEBOOK="$UPLOADER_DISCORD_URL"
    fi

    if [ "$CURRENT_DISCORD_WEBOOK" == "https://discord.com/api/webhooks/" ]; then
      __info "$(__yellow "No Discord credentials found, skip sending Discord notification")"
    else
      __info "Sending Discord notification..."

      if [ "$_type" == "start" ]; then
        local _body='{
          "content": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "embeds": [
            {
                "color": 16085214,
                "thumbnail": {
                  "url": "'$THUMBNAIL_CALC'"
                },
                "fields": [
                    {
                      "name": "Title",
                      "value": "'"$FULLTITLE"'"
                    },
                    {
                      "name": "Channel",
                      "value": "['"$CHANNEL_ID"']('"$CHANNEL_URL"')"
                    },
                    {
                      "name": "ID",
                      "value": "['"$VIDEO_ID"']('"$WEBPAGE_URL"')",
                      "inline": true
                    },
                    {
                      "name": "Date",
                      "value": "'"$UPLOAD_DATE"'",
                      "inline": true
                    }
                ]
            }
          ]
        }'
      elif [ "$_type" == "stop" ]; then
        local _SHOW_VIDEO_LENGTH='';
        if [ "$FILE_SUMMARY_TRIM" ]; then
          _SHOW_VIDEO_LENGTH=',
                    {
                      "name": "Video Duration (HH:MM:SS)",
                      "value": "'$FILE_SUMMARY_DURATION_CALC'",
                      "inline": true
                    },
                    {
                      "name": "File Size",
                      "value": "'$FILE_SUMMARY_SIZE_CALC'",
                      "inline": true
                    }';
        fi
        local _body='{
          "content": "'"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "embeds": [
            {
                "color": 1376511,
                "thumbnail": {
                  "url": "'$THUMBNAIL_CALC'"
                },
                "fields": [
                    {
                      "name": "Title",
                      "value": "'"$FULLTITLE"'"
                    },
                    {
                      "name": "Channel",
                      "value": "['"$CHANNEL_ID"']('"$CHANNEL_URL"')"
                    },
                    {
                      "name": "Views",
                      "value": "'"$VIEW_COUNT"'",
                      "inline": true
                    },
                    {
                      "name": "Likes",
                      "value": "'"$LIKE_COUNT"'",
                      "inline": true
                    },
                    {
                      "name": "Dislikes",
                      "value": "'"$DISLIKE_COUNT"'",
                      "inline": true
                    },
                    {
                      "name": "Average Rating",
                      "value": "'"$AVERAGE_RATING"'",
                      "inline": true
                    }'$_SHOW_VIDEO_LENGTH'
                ]
            }
          ]
        }'
      else
        local _body='{
          "content": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "embeds": [
            {
                "color": 16085214,
                "thumbnail": {
                  "url": "'$THUMBNAIL_CALC'"
                },
                "fields": [
                    {
                      "name": "Title",
                      "value": "'"$FULLTITLE"'"
                    },
                    {
                      "name": "Channel",
                      "value": "['"$CHANNEL_ID"']('"$CHANNEL_URL"')"
                    },
                    {
                      "name": "ID",
                      "value": "['"$VIDEO_ID"']('"$WEBPAGE_URL"')",
                      "inline": true
                    },
                    {
                      "name": "Date",
                      "value": "'"$UPLOAD_DATE"'",
                      "inline": true
                    }
                ]
            }
          ]
        }'
      fi

      curl -s -X POST -H 'Content-type: application/json' \
        -d "$_body" "$CURRENT_DISCORD_WEBOOK"
    fi
  fi
}

function func_process_youtube_metadata() {
  # Extract video info from JSON
  VIDEO_ID=$(echo "$METADATA" | jq -r '.id')
  FULLTITLE=$(echo "$METADATA" | jq -r '.fulltitle')
  DESCRIPTION=$(echo "$METADATA" | jq -r '.description')
  UPLOAD_DATE=$(echo "$METADATA" | jq -r '.upload_date')
  UPLOADER=$(echo "$METADATA" | jq -r '.uploader')
  CHANNEL_ID=$(echo "$METADATA" | jq -r '.channel_id')
  THUMBNAIL=$(echo "$METADATA" | jq -r '.thumbnail')
  WEBPAGE_URL=$(echo "$METADATA" | jq -r '.webpage_url')
  CHANNEL_URL=$(echo "$METADATA" | jq -r '.channel_url')
  VIEW_COUNT=$(echo "$METADATA" | jq -r '.view_count')
  LIKE_COUNT=$(echo "$METADATA" | jq -r '.like_count')
  DISLIKE_COUNT=$(echo "$METADATA" | jq -r '.dislike_count')
  AVERAGE_RATING=$(echo "$METADATA" | jq -r '.average_rating')

  # Filename (without path and file extension)
  FILENAME=$(echo "$METADATA" | jq -r '._filename' | sed -e 's/.mp4//' | sed -e 's/.webm//')
}

function func_process_channel_mapping() {
  # Find channel name mapping
  # https://stackoverflow.com/a/40027637/412385

  if [ "$CHANNEL_ID" ]; then
    UPLOADER_MAPPED_RAW=`echo "$CONFIG_RAW" | jq -r --arg CHANNEL_ID "$CHANNEL_ID" \
      '.map[] | select(.youtube | contains($CHANNEL_ID))'`

    # Check if current uploader has custom name mapping in config
    UPLOADER_MAPPED=`echo "$UPLOADER_MAPPED_RAW" | jq -r .name`

    if [ ! -z "${UPLOADER_MAPPED// }" ]; then
      __debug "Channel name mapping found: $(__yellow "$UPLOADER") â†’ $(__green "$UPLOADER_MAPPED")"
      __debug "I will use $(__green "$UPLOADER_MAPPED") for folder name, embedding metadata, etc."
      UPLOADER="$UPLOADER_MAPPED"
    else
      __debug "Channel name mapping $(__yellow "not found"), consider adding it in config.yml"
      __debug "I will use $(__yellow "$UPLOADER") for folder name, embedding metadata, etc."
    fi

    # Check if current uploader has dedicated Discord Webhook
    UPLOADER_DISCORD_URL=`echo "$UPLOADER_MAPPED_RAW" | jq -r '.discord | select (.!=null)'`

    if [ "${UPLOADER_DISCORD_URL}" ]; then
      __debug "Discord URL Found: $(__green "$UPLOADER_DISCORD_URL")"
    fi

    # Check if current uploader has dedicated Telegram channel
    UPLOADER_TG_CHANNEL=`echo "$UPLOADER_MAPPED_RAW" | jq -r '.telegram | select (.!=null)'`

    if [ "${UPLOADER_TG_CHANNEL}" ]; then
      __debug "Telegram channel found: $(__green "$UPLOADER_TG_CHANNEL")"
    else
      __debug "Telegram channel $(__yellow "not found"), consider adding it in config.yml"
    fi

    # Check if current uploader has custom timezone
    UPLOADER_TIMEZONE=`echo "$UPLOADER_MAPPED_RAW" | jq -r '.timezone | select (.!=null)'`

    if [ -z "$UPLOADER_TIMEZONE" ]; then
      UPLOADER_TIMEZONE=`echo "$CONFIG_RAW" | jq -r '.config.timezone'`
    fi

  else
    __info "$(__red "Missing uploader ID!")"
    exit 1
  fi
}

function func_prepare_dir() {
  local _dir=$1
  [ -d "$_dir" ] || mkdir -p "$_dir"
}

function func_finalize_vars() {
  # Output preffix dir (without user base dir)
  # Also I replace slash with underscores here to avoid nesting directories
  # i.e.
  # å¤©å®® ã“ã“ã‚ / Kokoro Amamiya ã€ã«ã˜ã•ã‚“ã˜æ‰€å±žã€‘ will become:
  # å¤©å®® ã“ã“ã‚ï¼Kokoro Amamiya ã€ã«ã˜ã•ã‚“ã˜æ‰€å±žã€‘
  FILENAME_BASE=$(echo "$UPLOADER" | sed "s/\//ï¼/" | sed "s/ ï¼ /ï¼/")

  # Output base without filename
  OUTPUT_BASE="$BASE_DIR/$FILENAME_BASE"

  # Apply additional timestamp if file already exists
  if ([ -f "$OUTPUT_BASE/$FILENAME.ts" ] || [ -f "$OUTPUT_BASE/$FILENAME.mp4" ]); then
    local _time_start=$(date +"%H.%M.%S")
    FILENAME="$FILENAME-$_time_start"
    __info "$(__yellow "Filename already exists, using $FILENAME")"
  fi

  # Full output dir
  OUTPUT_PATH="$OUTPUT_BASE/$FILENAME"

  # Write prettified JSON metadata to file
  func_prepare_dir "$OUTPUT_BASE"
  METADATA_PRETTIFIED=`echo $METADATA | jq .`
  echo "$METADATA_PRETTIFIED" > "$OUTPUT_PATH.json"

  # Download thumbnail
  # yt-dlp has built-in thumbnail download feature via --write-all-thumbnails but it's not
  # perfect due to the limitation of YouTube API, yt-dlp will only get `hqdefault.jpg` for
  # finished streams (live streams not affected) because offical API only returns this size even
  # higher resolution is available (`maxresdefault.jpg`). So I created some additional checks here.
  #
  # For stream content, YouTube provides both `maxresdefault.jpg` and `maxresdefault_live.jpg`, but
  # `maxresdefault.jpg` is more reliable as `maxresdefault_live.jpg` will return black image
  # (200 HTTP code) even if the streamer set a smaller thumbnail that is only suitable at a smaller
  # size (hqdefault.jpg)
  #
  # Another scenario is that the streamer set an upcoming event with thumbnail-A. But she/he later
  # changes it to another (thumbnail-B) when stream goes live. `maxresdefault_live.jpg` seems always
  # returns thumbnail-A while `maxresdefault.jpg` can get the correct thumbnail-B.
  #
  # First download thumbnail provided from yt-dlp
  THUMBNAIL_CALC="$THUMBNAIL"
  curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"

  # Check thumbnail width
  THUMB_W=`exiv2 "$OUTPUT_PATH.jpg" | awk -F: '/Image size/ {print $2}' | cut -dx -f1 | tr -d ' '`
  if [ "$THUMB_W" -lt "1280" ]; then
    __info "Thumbnail ($THUMBNAIL_CALC) downloeded via yt-dlp is too small, try our own method"

    # Re-assign thumbnail URL
    THUMBNAIL_CALC="https://i.ytimg.com/vi/$VIDEO_ID/maxresdefault.jpg"

    # Check if thumbnail is available (has 200 HTTP response code)
    local _thumb_resp=$(curl -qSsfw "%{http_code}" $THUMBNAIL_CALC -o /dev/null)

    if [ "$_thumb_resp" != "200" ]; then
      __info "No high-res thumbnial (maxresdefault.jpg), failback to hqdefault.jpg"
      THUMBNAIL_CALC="https://i.ytimg.com/vi/$VIDEO_ID/hqdefault.jpg"
      curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"
    else
      curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"
    fi
  fi

  # Output summary
  SUMMARY="ID:        $VIDEO_ID
Title:     $FULLTITLE
URL:       $WEBPAGE_URL
Author:    $UPLOADER
Channel:   $CHANNEL_URL
Date:      $UPLOAD_DATE
Thumbnail: $THUMBNAIL_CALC
Filename:  $FILENAME
Location:  $OUTPUT_BASE/
Hostname:  $HOSTNAME
"

  # Trim additional whitespace, used by email body
  SUMMARY_TRIM=`echo "$SUMMARY" | perl -pe 's/: +/: /g'`
}

function func_download_youtube() {
  __info "Start downloading $FILENAME"

  # Log tail inspired by https://github.com/printempw/live-stream-recorder
  __info "Logging: tail -f \"$OUTPUT_PATH.log\""

  if [ "$CONTENT_STATE" == "live" ]; then
    if [ "$YTDL_STREAM" == "true" ]; then
      yt-dlp \
        --ignore-config \
        --hls-prefer-native \
        --hls-use-mpegts \
        --no-part \
        -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' \
        --retries 30 \
        --cookies cookies.txt \
        $YTDL_ARGS -o "$OUTPUT_PATH.ts" \
        "${WEBPAGE_URL}" >> "$OUTPUT_PATH.log" 2>&1
    else
      streamlink \
        --force \
        --http-timeout 180 \
        --hls-live-restart \
        --hls-segment-threads 10 \
        --hls-segment-timeout 120 \
        --hls-segment-attempts 300 \
        --hls-segment-ignore-names preloading \
        --hls-playlist-reload-attempts 30 \
        --hls-live-edge 5 \
        --hls-timeout 90 \
        --ringbuffer-size 256M \
        --loglevel trace \
        $STREAMLINK_ARGS -o "$OUTPUT_PATH.ts" \
        "${WEBPAGE_URL}" best >> "$OUTPUT_PATH.log" 2>&1
    fi
  elif [ "$CONTENT_STATE" == "video" ]; then
    if [ "$DL_TYPE" == "playlist" ]; then
      # TODO: You have to loop over all the videos to add metadata and thumbnail manually.
      # Or you can add the following parameters to handle it using yt-dlp automatically:
      #   --embed-thumbnail # requires AtomicParsley
      #   --add-metadata
      yt-dlp \
        --ignore-config \
        --download-archive archive.txt \
        --embed-thumbnail \
        --add-metadata \
        --external-downloader aria2c \
        --external-downloader-args '-j 16 -s 16 -x 16 -k 1M --retry-wait 10 --max-tries 10' \
        -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' \
        --write-auto-sub \
        --write-sub \
        --sub-lang en,zh-Hans,zh-Hant,ja,zh-Hans-en,zh-Hant-en,ja-en \
        --sub-format best \
        --convert-subs srt \
        --embed-subs \
        --retries 30 \
        --cookies cookies.txt \
        $YTDL_ARGS -o "$OUTPUT_PATH.ts" \
        "${WEBPAGE_URL}"
    else
      yt-dlp \
        --ignore-config \
        --external-downloader aria2c \
        --external-downloader-args '-j 16 -s 16 -x 16 -k 1M --retry-wait 10 --max-tries 10' \
        -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' \
        --write-auto-sub \
        --write-sub \
        --sub-lang en,zh-Hans,zh-Hant,ja,zh-Hans-en,zh-Hant-en,ja-en \
        --sub-format best \
        --convert-subs srt \
        --retries 30 \
        --cookies cookies.txt \
        $YTDL_ARGS -o "$OUTPUT_PATH.mp4" \
        "${WEBPAGE_URL}"
    fi
  else
    __info "Not a valid URL, skippping"
  fi
}

function func_download_bilibili() {
  __info "bilibili download func"
}

function func_finalize_download() {
  __info "Stop downloading"

  if [ "$SKIP_CONVERT" == "false" ]; then

    if [ "$CONTENT_STATE" == "live" ]; then
      # Convert from TS to MP4 (will override existing with -y option)
      __info "Converting to MP4"
      ffmpeg -i "$OUTPUT_PATH.ts" -y \
        -codec copy \
        "$OUTPUT_PATH.mp4" >> "$OUTPUT_PATH.log" 2>&1

      # Remove original TS file
      rm -f "$OUTPUT_PATH.ts"
    fi

    # Assign finalized path for later use
    OUTPUT_PATH_EXT=$OUTPUT_PATH.mp4
  else
    OUTPUT_PATH_EXT=$OUTPUT_PATH.ts
  fi

  if [ "$SKIP_METADATA" == "false" ]; then
    __info "Trying to write metadata"

    # Write metadata to MP4 if exists (will override existing with -y option)
    if [ -f "$OUTPUT_PATH.mp4" ]; then
      __info "Writing metadata"
      ffmpeg -i "$OUTPUT_PATH.mp4" -y \
        -codec copy \
        -metadata title="$FULLTITLE" \
        -metadata artist="$UPLOADER" \
        -metadata date="$UPLOAD_DATE" \
        -metadata description="$DESCRIPTION" \
        -metadata comment="$DESCRIPTION" \
        "$OUTPUT_PATH-metadata.mp4" >> "$OUTPUT_PATH.log" 2>&1
      rm -f "$OUTPUT_PATH.mp4" && mv "$OUTPUT_PATH-metadata.mp4" "$OUTPUT_PATH.mp4"
    else
      __info "$(__yellow "Output file not exists, skip writing metadata.")"
    fi
  fi

  # Get file summary for later use
  if [ -f "$OUTPUT_PATH_EXT" ]; then
    DOWNLOADED_FILE_SUMMARY=`ffprobe -i \
      "$OUTPUT_PATH_EXT" \
      -v quiet \
      -print_format json \
      -show_format \
      -show_streams \
      -hide_banner`

    FILE_SUMMARY_DURATION=`echo $DOWNLOADED_FILE_SUMMARY | jq -r .streams[0].duration`
    FILE_SUMMARY_DURATION_INIT=${FILE_SUMMARY_DURATION%.*}
    FILE_SUMMARY_DURATION_CALC=$(__convert_seconds $FILE_SUMMARY_DURATION_INIT)
    FILE_SUMMARY_SIZE=`echo $DOWNLOADED_FILE_SUMMARY | jq -r .format.size`
    FILE_SUMMARY_SIZE_CALC=$(numfmt --to=iec-i --suffix=B $FILE_SUMMARY_SIZE)
    FILE_SUMMARY="Duration:  $FILE_SUMMARY_DURATION_CALC
Size:      $FILE_SUMMARY_SIZE_CALC
Path:      $HOSTNAME:$OUTPUT_PATH_EXT
" && echo -e "\n$FILE_SUMMARY"
  else
    FILE_SUMMARY="File summary not available due to missing files"
    __info "$(__yellow "File summary not available due to missing files.")"
  fi

  # Trim additional whitespace, used by email body
  FILE_SUMMARY_TRIM=`echo "$FILE_SUMMARY" | perl -pe 's/: +/: /g'`

  # Additional sleep to ensure the stream is stopped on YouTube frontend, you can also increase
  # --hls-timeout to make sure the streamer correctly stops the stream, but the longer the
  # --hls-timeout you set, the longer the notification you will get after the streamer actually
  # stops his/her stream.
  sleep 10
}

#
# Executes
#

# Init scripts with `--init` specified
INIT_SCRIPT="${PARAM_INIT_SCRIPT:-"false"}"
if [ "$INIT_SCRIPT" == "true" ]; then
  func_check_deps
  exit 0
fi

# Show current version
SHOW_VERSION="${PARAM_SHOW_VERSION:-"false"}"
if [ "$SHOW_VERSION" == "true" ]; then
  echo "$BIN_VERSION"
  exit 0
fi

# Print usage if no URL passed
if [ ! -n "$1" ]; then
  echo "live-dl v$BIN_VERSION
by Tunghsiao Liu and contributers:
https://github.com/sparanoid/live-dl/graphs/contributors

Usage: $0 url [options]

Run $0 --init to initialize this script and download required dependencies.

Examples:
  Monitor specific channel, download stream when channel goes live:
  live-dl https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg/live
  live-dl https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg
  live-dl UC1opHUrw8rvnsadT-iGp7Cg

  Download specific upload, this can be a live stream, finished stream or normal video:
  live-dl https://www.youtube.com/watch?v=S3CAGeeMRvo
  live-dl S3CAGeeMRvo

  Download all uploads from a playlist (unstable):
  live-dl https://www.youtube.com/playlist?list=UU1opHUrw8rvnsadT-iGp7Cg

Options:
  --mode, -m                  Running mode, default: download, available: metadata, notifier
                              - download: monitor and download streams
                              - metadata: only download metadata (JSON output and thumbnail)
                              - notifier: send notifications without downloading
  --filter                    Filter video titles. Only works in channel mode. Can be single string
                              or regex expression. ie. ASMR|æ­Œ
  --output, -o                Base output directory, default: ./downloads
  --interval, -i              Loop interval, unit: second, default: 10.
                              WARNING: Do not set this value too low or your IP may get rate
                              limited by YouTube
  --user-agent, -u            Custom User-Agent for cURL requests
  --image-proxy               Custom image proxy service for notifications
  --ytdl-stream               Use yt-dlp to handle livestreams instead of streamlink
  --ytdl-args                 Passing additional options to yt-dlp. options should be quoted
  --streamlink-args           Passing additional options to streamlink. options should be quoted
  --skip-convert              Skip converting TS file to MP4
  --skip-metadata             Skip embedding metadata
  --skip-email                Skip sending email notification
  --skip-slack                Skip sending Slack notification
  --skip-telegram             Skip sending Telegram notification
  --skip-discord              Skip sending Discord notification
  --once, -1                  Run only once, default: false
  --debug                     Show debug output (aka. verbose mode), default: false
  --version, -v                Show script version"
  exit 1
fi

# Check if we have config.yml
if ! [ -f config.yml ]; then
  __info "$(__red "No config.yml, 'cp config.example.yml config.yml' and rerun this script.")"
  exit 1;
else
  CONFIG_RAW=`cat config.yml | yq -r .`
fi

# Set default settings

# Remove trailing slash for user defined directory
# https://stackoverflow.com/a/1848456/412385
_PARAM_BASE_DIR=${PARAM_BASE_DIR%/*}

# Expand $HOME so that later I can replace `~` with escaped $HOME path in `config.yml`
HOME_EXPANDED=$(echo "$HOME" | sed -e 's/\//\\\//g')

CONFIG_MODE=`echo $CONFIG_RAW | jq -r '.config.mode | select(.!=null)'`
CONFIG_FILTER=`echo $CONFIG_RAW | jq -r '.config.filter | select(.!=null)'`
CONFIG_BASE_DIR=`echo $CONFIG_RAW | jq -r .config.output | sed -e 's/~/'"$HOME_EXPANDED"'/g'`
CONFIG_INTERVAL=`echo $CONFIG_RAW | jq -r '.config.interval | select(.!=null)'`
CONFIG_USER_AGENT=`echo $CONFIG_RAW | jq -r '.config.user_agent | select(.!=null)'`
CONFIG_IMAGE_PROXY=`echo $CONFIG_RAW | jq -r '.config.image_proxy | select(.!=null)'`
CONFIG_YTDL_STREAM=`echo $CONFIG_RAW | jq -r '.config.ytdl_stream | select(.!=null)'`
CONFIG_YTDL_ARGS=`echo $CONFIG_RAW | jq -r '.config.ytdl_args | select(.!=null)'`
CONFIG_STREAMLINK_ARGS=`echo $CONFIG_RAW | jq -r '.config.streamlink_args | select(.!=null)'`
CONFIG_SKIP_CONVERT=`echo $CONFIG_RAW | jq -r '.config.skip_convert | select(.!=null)'`
CONFIG_SKIP_METADATA=`echo $CONFIG_RAW | jq -r '.config.skip_metadata | select(.!=null)'`
CONFIG_SKIP_EMAIL=`echo $CONFIG_RAW | jq -r '.config.skip_email | select(.!=null)'`
CONFIG_SKIP_SLACK=`echo $CONFIG_RAW | jq -r '.config.skip_slack | select(.!=null)'`
CONFIG_SKIP_TELEGRAM=`echo $CONFIG_RAW | jq -r '.config.skip_telegram | select(.!=null)'`
CONFIG_SKIP_DISCORD=`echo $CONFIG_RAW | jq -r '.config.skip_discord | select(.!=null)'`
CONFIG_ONE_TIME=`echo $CONFIG_RAW | jq -r '.config.one_time | select(.!=null)'`
CONFIG_EMAIL_PROVIDER=`echo $CONFIG_RAW | jq -r '.config.email_provider | select(.!=null)'`
CONFIG_MAILGUN_API=`echo $CONFIG_RAW | jq -r '.config.mailgun.api | select(.!=null)'`
CONFIG_MAILGUN_DOMAIN=`echo $CONFIG_RAW | jq -r '.config.mailgun.domain | select(.!=null)'`
CONFIG_MAILGUN_RECEIPT=`echo $CONFIG_RAW | jq -r '.config.mailgun.receipt | select(.!=null)'`
CONFIG_SES_ACCESS=`echo $CONFIG_RAW | jq -r '.config.ses.access | select(.!=null)'`
CONFIG_SES_SECRET=`echo $CONFIG_RAW | jq -r '.config.ses.secret | select(.!=null)'`
CONFIG_SES_DOMAIN=`echo $CONFIG_RAW | jq -r '.config.ses.domain | select(.!=null)'`
CONFIG_SES_RECEIPT=`echo $CONFIG_RAW | jq -r '.config.ses.receipt | select(.!=null)'`
CONFIG_SLACK_WEBHOOK=`echo $CONFIG_RAW | jq -r '.config.slack.webhook | select(.!=null)'`
CONFIG_TELEGRAM_BOT=`echo $CONFIG_RAW | jq -r '.config.telegram.bot | select(.!=null)'`
CONFIG_TELEGRAM_CHANNEL=`echo $CONFIG_RAW | jq -r '.config.telegram.channel | select(.!=null)'`
CONFIG_DISCORD_WEBHOOK=`echo $CONFIG_RAW | jq -r '.config.discord.webhook | select(.!=null)'`

MODE="${PARAM_MODE:-$CONFIG_MODE}"
FILTER="${PARAM_FILTER:-$CONFIG_FILTER}"
BASE_DIR="${_PARAM_BASE_DIR:-$CONFIG_BASE_DIR}"
INTERVAL="${PARAM_INTERVAL:-$CONFIG_INTERVAL}"
USER_AGENT_BACKWARD_COMPATIBILITY="${CONFIG_USER_AGENT:-$LEGACY_USER_AGENT}"
USER_AGENT="${PARAM_USER_AGENT:-$USER_AGENT_BACKWARD_COMPATIBILITY}"
IMAGE_PROXY="${PARAM_IMAGE_PROXY:-$CONFIG_IMAGE_PROXY}"
YTDL_STREAM="${PARAM_YTDL_STREAM:-$CONFIG_YTDL_STREAM}"
YTDL_ARGS="${PARAM_YTDL_ARGS:-$CONFIG_YTDL_ARGS}"
STREAMLINK_ARGS="${PARAM_STREAMLINK_ARGS:-$CONFIG_STREAMLINK_ARGS}"
SKIP_CONVERT="${PARAM_SKIP_CONVERT:-$CONFIG_SKIP_CONVERT}"
SKIP_METADATA="${PARAM_SKIP_METADATA:-$CONFIG_SKIP_METADATA}"
SKIP_EMAIL="${PARAM_SKIP_EMAIL:-$CONFIG_SKIP_EMAIL}"
SKIP_SLACK="${PARAM_SKIP_SLACK:-$CONFIG_SKIP_SLACK}"
SKIP_TELEGRAM="${PARAM_SKIP_TELEGRAM:-$CONFIG_SKIP_TELEGRAM}"
SKIP_DISCORD="${PARAM_SKIP_DISCORD:-$CONFIG_SKIP_DISCORD}"
ONE_TIME="${PARAM_ONE_TIME:-$CONFIG_ONE_TIME}"
URL_INPUT="$1"

# Print current variables for reference
__info "URL (URI) to process           : ${URL_INPUT}"
__info "Mode                           : ${MODE}"
__info "Output base dir                : ${BASE_DIR}"
__info "Run interval (when loop)       : ${INTERVAL}"
__info "Custom image proxy             : ${IMAGE_PROXY}"
__info "Use yt-dlp for streams         : ${YTDL_STREAM}"
__info "Skip convert                   : ${SKIP_CONVERT}"
__info "Skip embedding metadata        : ${SKIP_METADATA}"
__info "Skip email notification        : ${SKIP_EMAIL}"
__info "Skip Slack notification        : ${SKIP_SLACK}"
__info "Skip Telegram notification     : ${SKIP_TELEGRAM}"
__info "Skip Discord notification      : ${SKIP_DISCORD}"
__info "Email provider                 : ${CONFIG_EMAIL_PROVIDER}"
__info "One-time execution             : ${ONE_TIME}"

# Process URL from user parameter
func_create_url "$URL_INPUT"

# Main loop
while true; do
  __info "Checking $DL_URL..."

  # Monitor live streams of a specific channel
  while true; do
    # Check if url types and live available
    # After creating URL with func_create_url, I need to further process the URL to determine
    # the type (video, live stream) and state (is live or not) of the given URL
    func_check_state "$DL_URL"

    if [ "$CONTENT_STATE" == "live" ]; then
      break
    elif [ "$CONTENT_STATE" == "video" ]; then
      ONE_TIME="true"
      break
    else
      __debug "Not valid at the moment, continue running"
    fi

    __debug "Stream unavailable, retry in ${INTERVAL}s..."
    sleep $INTERVAL
  done

  # Get video(s) metadata
  __info "$(__green "Prepare downloading...")"
  __debug "Download platform: $DL_PLATFORM"
  __debug "Download type: $DL_TYPE"
  __debug "Download mode: $MODE"

  #
  # Platform: YouTube
  #
  if [ "$DL_PLATFORM" == "YouTube" ]; then
    # Print summary
    echo -e "\n$SUMMARY"

    #
    # Type: YouTube channel
    #
    if [ "$DL_TYPE" == "channel" ]; then

      #
      # Mode: download
      #
      if [ "$MODE" == "download" ]; then
        # Send notifications
        # https://stackoverflow.com/a/49819711/412385
        _break=$'\n\n'
        func_send_email "ðŸ”´ [YouTube] $UPLOADER - $FULLTITLE" "$SUMMARY_TRIM$_break$DESCRIPTION"
        func_send_slack "start"
        func_send_telegram "start"
        func_send_discord "start"
        func_download_youtube
        func_finalize_download
        func_send_email "âš«ï¸ [YouTube] $UPLOADER - $FULLTITLE" "$FILE_SUMMARY_TRIM"

      #
      # Mode: metadata only
      #
      elif [ "$MODE" == "metadata" ]; then
        __info "Metadata only mode, no video will be downloaded."
        exit 0

      #
      # Mode: notifier
      #
      elif [ "$MODE" == "notifier" ]; then
        func_send_slack "start"
        func_send_telegram  "start"
        func_send_discord "start"
        __info "Notifier mode, no video will be downloaded, continue monitoring..."

        while true; do
          func_check_state "$DL_URL" "lazy"

          if [ "$CONTENT_STATE" != "live" ]; then
            __info "Live stopped"
            break
          fi

          __info "Still streaming, retry in ${INTERVAL}s..."
          sleep $INTERVAL
        done

      #
      # Mode: unknown
      #
      else
        __info "$(__red "Unknown mode, check your config")"
        exit 1
      fi

    #
    # Type: YouTube video
    #
    elif [ "$DL_TYPE" == "video" ]; then

      if [ "$MODE" == "download" ]; then
        func_download_youtube
        func_finalize_download
        exit 0
      else
        __info "Metadata only mode, no video will be downloaded."
        exit 0
      fi

    #
    # Type: YouTube playlist
    #
    elif [ "$DL_TYPE" == "playlist" ]; then
      __info "Type: YouTube playlist"

    #
    # Type: Unknown
    #
    else
      __info "Type: Unknown"
    fi

  elif [ "$DL_PLATFORM" == "bilibili" ]; then
    __info "Download platform: Bilibili"
  else
    __info "Download platform: Unknown"
  fi

  # Break current loop if only run once
  [ "$ONE_TIME" == "true" ] && break
done
